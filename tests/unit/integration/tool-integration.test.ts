import { describe, test, expect, beforeEach, afterEach } from "vitest";
import { ToolManager } from "../../../src/tools/ToolManager";
import { TestUtils } from "../../helpers/TestUtils";
import * as path from "path";

describe("Tool Integration", () => {
  let toolManager: ToolManager;
  let tempDir: string;

  beforeEach(async () => {
    toolManager = new ToolManager();
    tempDir = await TestUtils.createTempDir();
  });

  afterEach(async () => {
    await TestUtils.cleanupTempDir(tempDir);
  });

  test("should integrate foundation analyzer and file reader", async () => {
    // Create a test project structure
    await TestUtils.createTestFiles(tempDir, {
      "package.json": JSON.stringify({
        name: "test-integration",
        dependencies: { react: "^18.0.0" },
      }),
      "src/App.jsx":
        "export default function App() { return <div>Hello World</div> }",
      "src/index.js": 'import App from "./App"; console.log("App loaded");',
      "README.md": "# Integration Test Project\n\nThis tests tool integration.",
    });

    // First, analyze the project structure
    const treeResult = await toolManager.executeToolForResult(
      "get_project_tree",
      {
        path: tempDir,
      }
    );

    expect(treeResult).toContain("package.json");
    expect(treeResult).toContain("src"); // Changed from 'src/'
    expect(treeResult).toContain("README.md");

    // Then read key files based on what we found
    const keyFiles = [
      path.join(tempDir, "package.json"),
      path.join(tempDir, "src/App.jsx"),
      path.join(tempDir, "README.md"),
    ];

    const filesResult = await toolManager.executeToolForResult("read_files", {
      paths: keyFiles,
    });

    expect(filesResult).toContain("test-integration");
    expect(filesResult).toContain("react");
    expect(filesResult).toContain("Hello World");
    expect(filesResult).toContain("Integration Test Project");
  });

  test("should integrate file writer and reader for round-trip testing", async () => {
    const testFiles = [
      {
        path: path.join(tempDir, "component.jsx"),
        content:
          "export default function Component() { return <div>Test</div> }",
      },
      {
        path: path.join(tempDir, "utils.js"),
        content: 'export function helper() { return "helper function" }',
      },
    ];

    // Write files
    const writeResult = await toolManager.executeToolForResult("write_files", {
      files: testFiles,
    });
    expect(writeResult).toContain("2/2 files written successfully");

    // Read them back
    const filePaths = testFiles.map((f) => f.path);
    const readResult = await toolManager.executeToolForResult("read_files", {
      paths: filePaths,
    });

    // Verify content
    testFiles.forEach((file) => {
      expect(readResult).toContain(file.content);
    });
  });

  test("should handle complete workflow: analyze -> read -> write", async () => {
    // Start with initial project
    await TestUtils.createTestFiles(tempDir, {
      "package.json": JSON.stringify({
        name: "workflow-test",
        version: "1.0.0",
      }),
      "src/index.js": 'console.log("Initial version");',
    });

    // Step 1: Analyze project
    const treeResult = await toolManager.executeToolForResult(
      "get_project_tree",
      {
        path: tempDir,
      }
    );
    expect(treeResult).toContain("package.json");
    expect(treeResult).toContain("src"); // Changed from 'src/'

    // Step 2: Read existing files
    const existingFiles = [
      path.join(tempDir, "package.json"),
      path.join(tempDir, "src/index.js"),
    ];
    const readResult = await toolManager.executeToolForResult("read_files", {
      paths: existingFiles,
    });
    expect(readResult).toContain("workflow-test");
    expect(readResult).toContain("Initial version");

    // Step 3: Write new files based on analysis
    const newFiles = [
      {
        path: path.join(tempDir, "src/app.js"),
        content: '// New app file\nconsole.log("App initialized");',
      },
      {
        path: path.join(tempDir, "README.md"),
        content: "# Workflow Test\n\nGenerated by integration test.",
      },
    ];
    const writeResult = await toolManager.executeToolForResult("write_files", {
      files: newFiles,
    });
    expect(writeResult).toContain("2/2 files written successfully");

    // Step 4: Verify final project structure
    const finalTreeResult = await toolManager.executeToolForResult(
      "get_project_tree",
      {
        path: tempDir,
      }
    );
    expect(finalTreeResult).toContain("src");
    expect(finalTreeResult).toContain("README.md");
  });

  test("should validate all tools are working together", async () => {
    const { valid, invalid } = await toolManager.validateTools();

    // All core tools should be valid
    expect(valid).toContain("get_project_tree");
    expect(valid).toContain("read_files");
    expect(valid).toContain("write_files");
    expect(valid).toContain("run_command");

    // No tools should be invalid in a properly set up environment
    expect(invalid.length).toBe(0);
  });

  test("should handle shell commands in workflow context", async () => {
    // Create a basic Node.js project structure
    await TestUtils.createTestFiles(tempDir, {
      "package.json": JSON.stringify({
        name: "shell-integration-test",
        scripts: {
          test: 'echo "tests passed"',
        },
      }),
    });

    // Use shell executor to run project commands
    const result = await toolManager.executeToolForResult("run_command", {
      command: `cd "${tempDir}" && npm run test`,
    });

    expect(result).toContain("tests passed");
  });
});
